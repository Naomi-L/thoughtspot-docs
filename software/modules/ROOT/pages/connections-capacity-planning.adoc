= Capacity planning for connections
:last_updated: 06/28/2023
:linkattrs:
:page-partial:
:page-aliases:
:experimental:
:description: Using Connections, you can perform live queries on external databases.

This article provides hardware requirements and recommendations for using connections with ThoughtSpot. Please note that actual hardware requirements will vary depending on many factors like number of users, groups, Worksheets, Liveboards, and more.

These recommendations are only for connections to cloud data warehouses in ThoughtSpot.

== ThoughtSpot architecture

=== Single node

This architecture diagram shows a very high level view of ThoughtSpot and how it generates answers to business queries.

image::cap_planning_illo_1.png[]

=== Multi-node

In multi-node setup, multiple nodes work together to generate Answers. Multi-node setup provides High Availability and scalability to ThoughtSpot service. This architecture diagram shows how different nodes in the cluster work together to provide the service to the end user.


image::cap_planning_illo_2.png[]

== Factors influencing capacity

There are numerous factors which affect the capacity required for connections in ThoughtSpot.

=== Number of concurrent active users

The number of concurrent active users is the number of users actively interacting with ThoughtSpot at any point in time. More concurrent active users mean more requests to the system which require CPU and memory to process.

The number of requests that the system can handle depends on the type of request and metadata in the system. For example, the CPU and memory required to make object metadata create/update calls are higher than object read calls. Similarly, a customer with a large number of users or groups may need more resources to process the same request compared to a customer with a simpler setup.

Note that the cloud data warehouse can also limit the total number of requests that a system can handle. Tuning and scaling the cloud data warehouse to meet request-rate requirements is beyond the scope of this documentation.

The general recommendation is that ThoughtSpot can handle 30 concurrent read request/sec with 16 vCPU/128 GB RAM, provided the cloud data warehouse is able to handle the query load.

It is important to understand the usage pattern of the users to figure out the request rate generated by concurrent active users.

For example, if an active user opens a Liveboard which issues 20 requests, and then takes 4 minutes to go through the visualizations in the Liveboard, they are generating 5 requests/min. This means at 30 requests/sec, a 16 vCPU/128 GB RAM system can handle 360 concurrent active users. Please refer to xref:scale-up-out[Scale up/out]  for more information on how to set up the cluster for a higher request rate. There is no single rule that can help with this calculation, so we recommend that every customer do their own testing to find out the peak load and setup capacity accordingly.

=== Total number of objects in the system

The ThoughtSpot server caches all the objects and metadata associated with objects in memory so that it can serve user requests with low latency. These cached objects are replicated across all the nodes. During processing of user requests, services might make copies of objects as well. This requires the system to have sufficient memory to store and process objects. The actual amount of memory required depends on the type and complexity of objects in the system. Some examples of objects that take up memory are:

- Worksheets with a large number of columns
- Liveboards with many visualizations
- User groups with a large number of users
- Overall number of connections, Worksheets, Liveboards, users, groups, and views

In general, ThoughtSpot can hold and serve up to 500K objects in 128GB of RAM.

=== Number of indexed tokens

- xref:data-modeling-index.adoc[Manage suggestion indexing] provides details of what indexing is and how to control what is indexed or not. Based on the data model and data, customers should be able to get an estimate of the number of tokens that will be indexed.
- In general, we have seen 500MB of memory/1M token. It is a general recommendation, and actual memory usage will depend on the size of each token.
- Data tokens are replicated on two nodes in a multi-node cluster so the total memory required to hold indexed data tokens is twice the memory required for holding the total number of tokens in a multi-node cluster.

== Disk capacity

Disk capacity required depends on the following factors:

- Number of snapshots
- Total number of indexed tokens
- Total number of objects in the system

== Minimum hardware requirements for production

These are the minimum hardware requirements for a single-node cluster to run a ThoughtSpot application. For a multi-node setup, you can replicate this.

|===
|vCPU |RAM | Premium SSD Managed Disk Volume |Boot Volume

|16 vCPU
|128 GB RAM
|2 * 400GB
|250 GB
|===

[#scale-up-out]
== Scale up/out capability

ThoughtSpot is designed to scale up or scale out linearly with request rate. This means that a 2-node cluster can handle twice the number of requests compared to a single-node cluster. Similarly, a single node with 2X CPU and 2Y RAM can also handle twice the number of requests compared to a node with X CPU and Y RAM.

ThoughtSpot replicates all the metadata and objects across all nodes in the cluster, so it does not scale out with increase in metadata size. The only way to fit more metadata in the cluster would be to scale it up by adding more memory to the system.

== High Availability

ThoughtSpot is designed to be Highly Available. High Availability setup ensures that the ThoughtSpot application is available to the user in case one node fails. For High Availability setup, we require at least 3 nodes in the cluster.

You can also choose a backup or snapshot strategy to recover from failure. You can learn more about how to set up the backup and snapshot configuration for your cluster in xref:backup-strategy.adoc[Choose a backup strategy].

'''
> **Related information**
>
> * xref:aws-configuration-options.adoc[]
