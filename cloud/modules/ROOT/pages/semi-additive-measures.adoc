= Semi-additive measures with `first_value` and `last_value` functions
:author: Naomi
:last_updated: 4/24/24
:description:
:page-layout: default-cloud-early-access
:jira: SCAL-204538

A semi-additive measure, also known as snapshot data, is a measure that is usually aggregated for all attributes except for date and time. For certain measures, like inventory, you want to know what the value was at the beginning or end of a period. In that case, you can use the `last_value` function to find the inventory at the end of a month, rather than aggregating all values over the month. Similarly, you can use the `first_value` function to find out your stock at the beginning of a month.

NOTE: The `last_value` and `first_value` functions are Early Access. To enable these functions, contact your administrator.

The `last_value` and `first_value` functions leverage the equivalent SQL functions to return the last or first value for the defined data partition. This is not necessarily the last date of the date partition, but rather the last date for which there is a data entry. Note that if the underlying database does not support the last value or first value SQL functions, you cannot use these functions in ThoughtSpot.

== Formula syntax

The basic syntax of the last_value function is: `last_value(operation(measure or attribute),query_groups(),{column to order by})`. For example: `last_value(sum(balance),query_groups(),{transaction date})`.

The first argument, “sum(balance)” identifies the aggregate type and the measure column. The second argument, “query_groups”, partitions the data by column list; Use query_groups so that all columns in the search bar are included. The final argument “{transaction date}” orders the results by that column.

Note that `last_value` and `first_value` functions support the `query_groups() + ()` and `query groups() - ()` arguments like group aggregate functions do. You can enter multiple columns in the third argument.

You can include an outer aggregate function wrapping around the last_value function. If you don’t supply an outer aggregate, the aggregation defaults to SUM for numeric columns and MAX for non-numeric columns. You can use simple aggregates like sum, min, max, average, or advanced aggregates like group_average, moving_sum, and cumulative_sum.

If you do not specify an outer aggregate function in your formula, you can also add it from the search bar by entering “max”, “min”, “sum”, etc.


Consider the following example formulas:

* `Balance with Implicit Aggregate = last_value(sum(balance),query_groups(),{transaction date})` +
This formula is used to return the balance of inventory. There is no outer aggregation specified, so it defaults to `sum`. You can change the outer aggregation by entering the aggregation type in the search bar.

* `Balance with Explicit Aggregate = sum(last_value(sum(balance),query_groups(),{transaction date}))` +
This formula is used to return the balance of inventory. The outer aggregation is specified as `sum`. You cannot change the outer aggregation by entering a new aggregation type in the search bar.

* `Last date of partition = max(last_value(max(transaction date), query_groups(), {transaction date})` +
This formula is used to determine the last date an event occurred within a partition. It calculates the maximum transaction for the partition of query groups, or columns, that are referenced in the query.

* `xref:formulas-moving.adoc[3 Month Average Balance] = moving_average(last_value(sum(balance),query_groups(),{transaction date}), 3,1, transaction date)` +
This formula is used to find a moving average of the last three months before the current month.

* `xref:formulas-moving.adoc[3 Month Average Balance Advanced] = group_aggregate(moving_average(last_value(sum(balance),query_groups(),{transaction date}), 3,1, transaction date), query_groups(), query_filters()-{transaction date})` +
This formula is used to find a moving average of the last three months before the current month. It wraps the outer aggregation in another function so that you can add filters from the query, such as `this year`, and ensure the results are correct.

* `Regional Balance = group_aggregate(sum(last_value(sum(balance),query_groups(),{transaction date})),{Region}, query_filters())` +
This formula uses the `group_aggregate` function to calculate a level of detail expression, such as calculating the value of the balance at the regional level.



== Last_value example use case

For the following examples, consider a schema where the Stock Balances fact table is connected to the Date dimension table on the date column, and connected to the Product dimension table on the sku column.

[#stock-balances]
.Stock Balances Fact
[options=”header”]
|===
| date | sku | balance

| 1st Jan | ctr1 | 0
| 1st Jan | frb1 | 0
| 2nd Jan | ctr1 | 5
| 2nd Jan | frb1 | 10
| … | … | …
| 7th Jan | ctr1 | 0
| 7th Jan | frb1 | 6
| … | … | …
| 31st Jan | ctr1 | 8
| 31st Jan | frb1 | 4
| … | … | …
| 28th Feb | ctr1 | 6
| 28th Feb | frb1 | 6
| … | … | …
| 22nd Mar | ctr1 | 8
| 31st Mar | frb1 | 4
| … | … | …
| 30th Dec | ctr1 | 3
| 30th Dec | frb1 | 10
|===

[#date-dim]
.Date Dimension
[options=”header”]
|===
| date
|1st Jan
| 2nd Jan
| …
| 7th Jan
| …
| 31st Jan
| …
| 28th Feb
| …
| 22nd Mar
| 31st Mar
|...
| 31st Dec
|===

.Product Dimension
[options=”header”]
|===
| sku | product | category | group
| ctr1 | red t-shirt | t-shirts | clothing
| frb1 | blue runners | running | footwear
|===

Note that for the <<stock-balances,Stock Balances>> fact table, the grain is date and product. For each date, there is a row that defines what the balance for the product is at the sku level. The final transaction date is December 30th.

This is a semi-additive fact table; we can add up the balances for the product column, but we can’t add them up over all dates. The true balance for a select date is the balance recorded that day, it is not the sum of balances for the dates leading up to it.

To calculate the last value of the stock balance for a date, create the stock balance formula and add it to your search:

`stock balance =  last_value(sum(balance),query_groups(),{date})`

The formula returns a sum of all the balance values for the last date in the dataset. Here, the date column comes from the date dimension table. The final date in the <<date-dim,date dimension>> table is December 31st, but the last date for which there is a balance value is December 30th. The formula returns the balance for December 30th: 13.

If you search for `stock balance` `yearly`, the formula sums the balance values for the last date in each year. If your dataset contained multiple years, it would sum the balance for each year. Since this dataset contains only one year, the formula returns the balance for December 30th: 13.

If you search for `stock balance` `group` `january`, the formula sums the balance for the last date in the dataset, filtered for January, and separated by group. The formula returns the following table:

[options=”header”]
|===
| date | balance | group
| 31st Jan | 8 | footwear
| 31st Jan | 4 | footwear
|===

If you search for `stock balance` `weekly` `january` `group`, the formula shows the sum of all balance values for the last week for each group, filtered by january, and separated by group:

[options=”header”]
|===
| date | balance | group
| 7th Jan | 0 | clothing
| 7th Jan | 6 | footwear
| … | … | …
| 31st Jan | 8 | clothing
| 31st Jan | 4 | footwear
|===

Note that null or missing transaction data entries are not the same as zero-value data entries. If the balance shows as 0, a balancing transaction took place. Missing or null entries do not show as results for `last_value` or `first_value` functions. If you prefer to zero out the balance for a period, you must enter the data as a zero in the underlying data set for the final date of the period. In this case, you would enter the following data in the Stock Balances fact table:

[options=”header”]
|===
| date | sku | balance
| 31st Dec | ctr1 | 0
| 31st Dec | frb1 | 0
|===

Note that groups with separate last values can affect your results. If you search for `stock balance` `monthly`, ThoughtSpot returns the sum of all the balance values for the last date in each month. In this case, you get the following table:

[options=”header”]
|===
| date | balance
| January | 12
| February | 12
| March | 4
| December | 13
|===

Note that the balance for March is the balance for the last date in the data set, March 31st.

If you instead search for `stock balance` `monthly` `group`, ThoughtSpot returns a sum of all the balances for the last date in each month *for each group*. For March, this includes the values from March 31st and March 22nd, since the formula sums the individual values for each column. You get the following table:

[options=”header”]
|===
| date | balance
| January | 12
| February | 12
| March | 12
| December | 13
|===

== Modeling for slowly-changing dimensions


Sometimes, you want to model data for search using a model that captures both the current value and the historical values of an attribute. You need to plan for the data you expect to see as a visualization; Do you expect to see the current value of an attribute and apply that across all historical transactions, or do you expect to see the attribute at the time of the transaction?

=== Surrogate keys

We recommend using surrogate keys to model slowly-changing dimensions. Surrogate keys are when fact and dimensional tables are joined on the key column rather than on the product unique identifier. For the following table, the surrogate key is the `Productscdkey` column:

[options=”header”]
|===
| Productscdkey | Productid | Product Name | Partition Date
| 1_1 | 1 | name1_1 | 01/07/2023
| 1_2 | 1 | name1_2 | 01/08/2023
| 1_3 | 1 | name1_3 | 01/15/2023
| 1_4 | 1 | name1_4 | 01/31/2023
| 2_1 | 2 | name2_1 | 01/31/2023
| 3_1 | 3 | name3_1 | 01/29/2023
| 3_2 | 3 | name3_2 | 01/31/2023
|===

The surrogate key uniquely identifies the dimension row that was valid at that transaction date. For example, this table shows three products, with IDs 1, 2, and 3. The names of products 1 and 3 changed over time. For product 1, name1_1 was valid until the 7th, name 1_2 was valid from the 8th to the 15th, name1_3 was valid from the 15th to the 31st, etc.

In order to make tables of slowly-changing dimensions easier to read, we recommend including a zeroed transaction so that the balance for date periods (weekly, monthly, quarterly, yearly) displays only the balance for the most recent record. If you do not zero the transactions, ThoughtSpot displays the value of the balance at each attribute change.

To zero the transactions for this table, you would enter a balance of zero for each change of the Productscdkey column, for the date *after* which each product name was changed. This shows a zeroed balance for visualizations, without affecting the data for the actual attribute.

=== Range joins (not recommended)

If you are unable to change the underlying data of a table to zero out transactions, you can use range joins rather than surrogate keys. In this method, you join fact and dimensional tables via a range join for the transaction date and product identifier. For example, you join fact.productid to dim.productid and join fact.date to dim.date with fact.date >=dim.fromdate and fact.date \<= dim.todate.

For date periods (weekly, monthly, quarterly, yearly), ThoughtSpot displays the value for each of the attributes in the period.

NOTE: ThoughtSpot does not display the balance for the end of the period, but rather the last balance for the value that changed in the period.

== Non-recommended models

We do not recommend data models which include slow-changing dimension attributes on the fact table, causing the fact grain to be lower than the foreign key columns.

Consider the following table:

[options=”header”]
|===
| Date | Productid | Storeid | Balance | Currentprice | Markdownflag | Regularprice
| 01/01/2023 | 1 | 1 | 10 | 9 | c | 10
| 01/02/2023 | 1 | 1 | 10 | {Null} | {Null} | 10
| 01/03/2023 | 1 | 1 | 9 | 9 | c | 10
| 01/04/2023 | 1 | 1 | 0 | 9 | c | 10
| 01/05/2023 | 1 | 1 | 20 | 5 | d | 10
| 01/06/2023 | 1 | 1 | 5 | 5 | d | 10
| 01/07/2023 | 1 | 1 | 2 | 5 | d | 10
|===

The correct result for the last value of this balance on a weekly granularity is:

[options=”header”]
|===
| Weekly Transaction Date | Product Name | Total Balance | Partition Date
| 12/26/2022 | name1 | 10 | 01/01/2023
| 01/02/2023 | name1 | 2 | 01/07/2023
|===

Here, ThoughtSpot displays the weekly transaction date as the first date of the week.

However, if you include the attributes `current price` `markdown flag` `regular price` in your search, the following table results:

[#anti-pattern]
[options=”header”]
|===
| Weekly Transaction Date | Product Name | Current Price | Markdown flag | Regular Price | Total Balance
| 12/26/2022 | name1 | 9 | c | 10 | 10
| 01/02/2023 |  name1 | {Null} | {Null} | 10 | 10
| 01/02/2023 |  name1 | 9 | c | 10 | 0
| 01/02/2023 |  name1 | 5 | d | 10 | 2
|===

Note that due to the attribute changes, the table records multiple balances for the week beginning on 01/02/2023.

We recommend capturing the current price, markdown flag, and regular price as slowly-changing dimensions with a surrogate key. If you cannot modify the underlying data structure, you can either create <<formulas-ignore,formulas to ignore the attributes>> in a table that give you repeating balances for the same date or write <<formulas-attributes,last_value formulas for the attribute columns>>.

[#formulas-ignore]
=== Formulas that ignore attributes in a fact table

To create formulas that ignore the attributes in a table, you could use the following base formula:

`balance =  last_value(sum(balance),query_groups(),{transaction date})`

In this example, the query groups would be the weekly date, the product name, the current price, the markdown flag, and the regular price. The formula returns the value for each combination of attributes, like the <<anti-pattern,table above>>.

To modify the formula so it ignores the attribute grouping, you can use the following formula:

`balance ignoring attributes grouping = last_value(sum(balance),query_groups() -(currentprice, markdownflag, regularprice),{transaction date})`

This formula returns the correct value for the balance at the end of the week, assuming you haven’t applied any filters.

To modify the formula so it ignores attribute grouping and filters, use the following formula:

`Balance ignore attribute filters = group_aggregate(sum(last_value(sum(balance), query_groups()-(currentprice, regularprice,markdownflag),{transaction date})), query_groups(), query_filters() - (currentprice, regularprice, markdownflag))`

[#formulas-attributes]
=== Formulas for attributes in a fact table

If you want to instead view the last value of attributes in a given period, you can create formulas like the following:

`Last Current Price = max(last_value(max(currentprice), query_groups(), {transaction date}))`

`Last Regular Price = max(last_value(max(Regularprice), query_groups(), {transaction date}))`

`Last Markdown Flag = max(last_value(max(Markdownflag), query_groups(), {transaction date}))`



== Limitations

. Semi-additive functions cannot span multiple fact tables.
. Semi-additive functions cannot contain only constant expressions. For example, if you create a formula with no references to a column, such as `last_value(sum(1), {}, {true})`, ThoughtSpot will not support the function.
. You cannot combine different partitioning and ordering clauses in different semi-additive functions from the same table, in the same query. That is, a case where formula 1 partitions on Date and Product, and formula 2 partitions on Date, Product, and Client.
. Average, Variance, Standard Deviation and Unique Count do not work with semi-additive functions across an attribution query. That is, multiple fact tables with at least one non-shared attribute.
. We do not support semi-additive functions and unique count functions from the same table. Note that a work-around exists by wrapping the unique count in a group_aggregate function. For example, `group_aggregate(unique_count(product),query_groups()+{},query_filters())`.
. Advanced aggregates (group, cumulative, moving and rank) cannot be used *within* the definition of semi-additive functions. Note they can be used to wrap these functions as outer aggregation.
